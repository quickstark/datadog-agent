# At the top of the file, add a comment about organization secrets
# This workflow uses both repository secrets (project-specific) and organization secrets (shared infrastructure)
# 
# Organization Secrets (set once, used everywhere):
# - SYNOLOGY_HOST, SYNOLOGY_SSH_PORT, SYNOLOGY_USER, SYNOLOGY_SSH_KEY
# - DOCKERHUB_USER, DOCKERHUB_TOKEN
#
# Repository Secrets (project-specific):
# - DD_API_KEY (OPW secrets removed - deployed separately)
# - Any project-specific database credentials, etc.

name: Build and Deploy Datadog Agent
on:
  workflow_dispatch:  # Allow manual triggering
  push:
    branches: [ main ]
    paths:
      - 'Dockerfile'
      - 'datadog.yaml'
      - 'docker-compose.yaml'
      - 'conf.d/**'
      - 'system-probe.yaml'
      - 'scripts/**'
      - '.github/workflows/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'Dockerfile'
      - 'datadog.yaml'
      - 'docker-compose.yaml'
      - 'conf.d/**'
      - 'system-probe.yaml'
      - 'scripts/**'
      - '.github/workflows/**'

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      # Set up Docker Buildx for multi-platform builds
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      # Login to Docker Hub
      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USER }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}
      
      # Install Datadog CI for deployment tracking
      - name: Install Datadog CI
        run: |
          npm install -g @datadog/datadog-ci
          datadog-ci version
      
      # Build and push custom Datadog Agent image
      - name: Build and push Datadog Agent image
        id: docker_build_agent
        uses: docker/build-push-action@v5
        with:
          context: .
          platforms: linux/amd64  # Synology DS923+ AMD64 compatibility
          push: true
          tags: |
            ${{ secrets.DOCKERHUB_USER }}/dd-agent:latest
            ${{ secrets.DOCKERHUB_USER }}/dd-agent:${{ github.sha }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          labels: |
            org.opencontainers.image.source=${{ github.server_url }}/${{ github.repository }}
            org.opencontainers.image.revision=${{ github.sha }}
            org.opencontainers.image.created=${{ steps.meta.outputs.date }}
      
      # Validate configuration files
      - name: Validate Datadog configuration
        run: |
          echo "Validating Datadog configuration files..."
          
          # Check if required files exist
          if [ ! -f "datadog.yaml" ]; then
            echo "‚ùå datadog.yaml not found"
            exit 1
          fi
          
          if [ ! -f "Dockerfile" ]; then
            echo "‚ùå Dockerfile not found"
            exit 1
          fi
          
          # Basic YAML syntax validation
          python -c "import yaml; yaml.safe_load(open('datadog.yaml'))" || {
            echo "‚ùå datadog.yaml has invalid YAML syntax"
            exit 1
          }
          
          # Validate system-probe.yaml if it exists
          if [ -f "system-probe.yaml" ]; then
            python -c "import yaml; yaml.safe_load(open('system-probe.yaml'))" || {
              echo "‚ùå system-probe.yaml has invalid YAML syntax"
            exit 1
          }
            echo "‚úÖ system-probe.yaml is valid"
          fi
          
          # Validate conf.d configurations
          for config_file in conf.d/**/*.yaml; do
            if [ -f "$config_file" ]; then
              echo "Validating $config_file..."
              python -c "import yaml; yaml.safe_load(open('$config_file'))" || {
                echo "‚ùå $config_file has invalid YAML syntax"
                exit 1
              }
            fi
          done
          
          echo "‚úÖ All configuration files are valid"
      
      # Test network connectivity before attempting SCP
      - name: Test Synology connectivity
        run: |
          echo "üîç Testing connectivity to Synology host..."
          echo "Host: ${{ secrets.SYNOLOGY_HOST }}"
          echo "Port: ${{ secrets.SYNOLOGY_SSH_PORT }}"
          
          # Test DNS resolution
          echo "üì° DNS Resolution:"
          nslookup ${{ secrets.SYNOLOGY_HOST }} || true
          
          # Test port connectivity with timeout
          echo "üîå Port connectivity test:"
          timeout 30s nc -zv ${{ secrets.SYNOLOGY_HOST }} ${{ secrets.SYNOLOGY_SSH_PORT }} || {
            echo "‚ùå Port ${{ secrets.SYNOLOGY_SSH_PORT }} is not reachable"
            echo "This could be due to:"
            echo "  1. Firewall blocking the port"
            echo "  2. Host behind NAT without port forwarding"
            echo "  3. SSH service not running"
            echo "  4. ISP blocking the port"
            exit 1
          }
          
          echo "‚úÖ Basic connectivity test passed"

      # Copy configuration files to Synology (with enhanced error handling)
      - name: Copy configuration files to Synology (Primary Method)
        id: scp_primary
        uses: appleboy/scp-action@v0.1.7
        continue-on-error: true
        with:
          host: ${{ secrets.SYNOLOGY_HOST }}
          port: ${{ secrets.SYNOLOGY_SSH_PORT }}
          username: ${{ secrets.SYNOLOGY_USER }}
          key: ${{ secrets.SYNOLOGY_SSH_KEY }}
          source: "datadog.yaml,system-probe.yaml,conf.d/*"
          target: "/tmp/datadog-config/"
          strip_components: 0
          timeout: 60s
          command_timeout: 10m
          debug: true

      # Alternative file transfer method using SSH commands
      - name: Copy configuration files via SSH (Fallback Method)
        if: steps.scp_primary.outcome == 'failure'
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SYNOLOGY_HOST }}
          port: ${{ secrets.SYNOLOGY_SSH_PORT }}
          username: ${{ secrets.SYNOLOGY_USER }}
          key: ${{ secrets.SYNOLOGY_SSH_KEY }}
          timeout: 60s
          command_timeout: 10m
          script: |
            echo "üîÑ Using SSH fallback method for file transfer..."
            
            # Create target directory
            mkdir -p /tmp/datadog-config/conf.d/{postgres.d,sqlserver.d,snmp.d,mongo.d,docker.d,syslog.d,network_path.d}
            
            echo "üìÅ Created directory structure"
            
            # We'll recreate the config files directly on the server using environment variable substitution
            echo "üîß Creating configuration files with environment variables..."
            
            # Note: Files will be created in the SSH deployment step with proper variable substitution
            echo "‚úÖ SSH fallback method setup completed"

      # Create a pull-based configuration method (Ultimate Fallback)  
      - name: Create configuration archive for pull-based deployment
        if: steps.scp_primary.outcome == 'failure'
        run: |
          echo "üì¶ Creating configuration archive for pull-based deployment..."
          
          # Create a deployment package
          mkdir -p deployment-package
          cp datadog.yaml deployment-package/
          cp system-probe.yaml deployment-package/ 2>/dev/null || echo "system-probe.yaml not found, skipping"
          cp -r conf.d deployment-package/
          
          # Create deployment script with embedded configs
          cat > deployment-package/deploy-configs.sh << 'EOF'
          #!/bin/bash
          echo "üöÄ Pull-based configuration deployment starting..."
          
          # Create directory structure
          DATADOG_DIR="/volume1/docker/datadog-agent"
          sudo mkdir -p "$DATADOG_DIR/conf.d"/{postgres.d,sqlserver.d,snmp.d,mongo.d,docker.d,syslog.d,network_path.d}
          
          # Copy files from deployment package
          cp *.yaml "$DATADOG_DIR/"
          cp -r conf.d/* "$DATADOG_DIR/conf.d/"
          
          echo "‚úÖ Configuration files deployed successfully"
          EOF
          
          chmod +x deployment-package/deploy-configs.sh
          
          # Create archive
          tar -czf datadog-config-deployment.tar.gz deployment-package/
          
          echo "üì¶ Deployment package created: datadog-config-deployment.tar.gz"
          echo "üîó Alternative deployment method:"
          echo "   1. Download: wget https://github.com/${{ github.repository }}/releases/download/latest/datadog-config-deployment.tar.gz"
          echo "   2. Extract: tar -xzf datadog-config-deployment.tar.gz"
          echo "   3. Deploy: cd deployment-package && ./deploy-configs.sh"

      # Upload deployment package as artifact for manual retrieval
      - name: Upload deployment package as artifact
        if: steps.scp_primary.outcome == 'failure'
        uses: actions/upload-artifact@v4
        with:
          name: datadog-config-deployment
          path: deployment-package/
          retention-days: 30

      # Deploy to Synology
      - name: Deploy Datadog Agent to Synology
        id: synology_deploy
        uses: appleboy/ssh-action@v1.0.3
        if: steps.docker_build_agent.outcome == 'success' && github.ref == 'refs/heads/main'
        with:
          host: ${{ secrets.SYNOLOGY_HOST }}
          port: ${{ secrets.SYNOLOGY_SSH_PORT }}
          username: ${{ secrets.SYNOLOGY_USER }}
          key: ${{ secrets.SYNOLOGY_SSH_KEY }}
          script: |
            # Debug: Environment setup
            echo "üîß Setting up deployment environment..."
            echo "Current user: $(whoami)"
            echo "Current directory: $(pwd)"
            
            # Find Docker command
            if [ -f /usr/local/bin/docker ]; then
              DOCKER_CMD="/usr/local/bin/docker"
            elif [ -f /usr/bin/docker ]; then
              DOCKER_CMD="/usr/bin/docker"
            elif command -v docker >/dev/null 2>&1; then
              DOCKER_CMD="docker"
            else
              echo "‚ùå Docker not found"
              exit 1
            fi
            
            # Check Docker permissions
            if $DOCKER_CMD --version >/dev/null 2>&1; then
              echo "‚úÖ Docker accessible without sudo"
            elif sudo $DOCKER_CMD --version >/dev/null 2>&1; then
              echo "‚úÖ Docker accessible with sudo"
              DOCKER_CMD="sudo $DOCKER_CMD"
            else
              echo "‚ùå Cannot access Docker"
              exit 1
            fi
            
            echo "Using Docker: $DOCKER_CMD"
            echo "Note: Using standalone Docker deployment (no docker-compose needed)"
            
            # Set up Datadog Agent directory structure
            DATADOG_DIR="/volume1/docker/datadog-agent"
            echo "üìÅ Setting up Datadog Agent directory structure..."
            
            # Create main directory
            sudo mkdir -p "$DATADOG_DIR"
            sudo chown $(whoami):users "$DATADOG_DIR"
            
            # Create conf.d subdirectories
            sudo mkdir -p "$DATADOG_DIR/conf.d"
            sudo mkdir -p "$DATADOG_DIR/conf.d/postgres.d"
            sudo mkdir -p "$DATADOG_DIR/conf.d/mongo.d"
            sudo mkdir -p "$DATADOG_DIR/conf.d/snmp.d"
            sudo mkdir -p "$DATADOG_DIR/conf.d/syslog.d"
            sudo mkdir -p "$DATADOG_DIR/conf.d/network_path.d"
            sudo mkdir -p "$DATADOG_DIR/conf.d/networkdevice.d"
            
            # Set proper ownership
            sudo chown -R $(whoami):users "$DATADOG_DIR"
            
            # Copy configuration files from temp location
            echo "üìã Copying configuration files..."
            if [ -d "/tmp/datadog-config" ]; then
              # Copy main config files
              if [ -f "/tmp/datadog-config/datadog.yaml" ]; then
                cp "/tmp/datadog-config/datadog.yaml" "$DATADOG_DIR/"
                echo "‚úÖ Copied datadog.yaml"
              fi
              
              if [ -f "/tmp/datadog-config/system-probe.yaml" ]; then
                cp "/tmp/datadog-config/system-probe.yaml" "$DATADOG_DIR/"
                echo "‚úÖ Copied system-probe.yaml"
              fi
              
              # Copy conf.d directory structure
              if [ -d "/tmp/datadog-config/conf.d" ]; then
                cp -r /tmp/datadog-config/conf.d/* "$DATADOG_DIR/conf.d/" 2>/dev/null || echo "No conf.d files to copy"
                echo "‚úÖ Copied conf.d configurations"
              fi
              
              # Substitute environment variables in configuration files
              echo "üîß Substituting environment variables in configuration files..."
              
              # Datadog main configuration
              if [ -f "$DATADOG_DIR/datadog.yaml" ]; then
                echo "  üìã Updating datadog.yaml..."
                sed -i "s/\${DD_API_KEY}/${{ secrets.DD_API_KEY }}/g" "$DATADOG_DIR/datadog.yaml"
                echo "  ‚úÖ datadog.yaml updated"
              fi
              
              # PostgreSQL configuration
              if [ -f "$DATADOG_DIR/conf.d/postgres.d/conf.yaml" ]; then
                echo "  üìã Updating postgres.d/conf.yaml..."
                sed -i "s/\${POSTGRES_HOST}/${{ secrets.POSTGRES_HOST }}/g" "$DATADOG_DIR/conf.d/postgres.d/conf.yaml"
                sed -i "s/\${POSTGRES_PORT}/${{ secrets.POSTGRES_PORT }}/g" "$DATADOG_DIR/conf.d/postgres.d/conf.yaml"
                sed -i "s/\${POSTGRES_USER}/${{ secrets.POSTGRES_USER }}/g" "$DATADOG_DIR/conf.d/postgres.d/conf.yaml"
                sed -i "s/\${POSTGRES_PASSWORD}/${{ secrets.POSTGRES_PASSWORD }}/g" "$DATADOG_DIR/conf.d/postgres.d/conf.yaml"
                sed -i "s/\${POSTGRES_DATABASE}/${{ secrets.POSTGRES_DATABASE }}/g" "$DATADOG_DIR/conf.d/postgres.d/conf.yaml"
                echo "  ‚úÖ postgres.d/conf.yaml updated"
              fi
              
              # SQL Server configuration
              if [ -f "$DATADOG_DIR/conf.d/sqlserver.d/conf.yaml" ]; then
                echo "  üìã Updating sqlserver.d/conf.yaml..."
                sed -i "s/\${SQLSERVER_HOST}/${{ secrets.SQLSERVER_HOST }}/g" "$DATADOG_DIR/conf.d/sqlserver.d/conf.yaml"
                sed -i "s/\${SQLSERVER_PORT}/${{ secrets.SQLSERVER_PORT }}/g" "$DATADOG_DIR/conf.d/sqlserver.d/conf.yaml"
                sed -i "s/\${SQLSERVER_USER}/${{ secrets.SQLSERVER_USER }}/g" "$DATADOG_DIR/conf.d/sqlserver.d/conf.yaml"
                sed -i "s/\${SQLSERVER_PASSWORD}/${{ secrets.SQLSERVER_PASSWORD }}/g" "$DATADOG_DIR/conf.d/sqlserver.d/conf.yaml"
                echo "  ‚úÖ sqlserver.d/conf.yaml updated"
              fi
              
              # SNMP configuration
              if [ -f "$DATADOG_DIR/conf.d/snmp.d/conf.yaml" ]; then
                echo "  üìã Updating snmp.d/conf.yaml..."
                sed -i "s/\${ROUTER_IP}/${{ secrets.ROUTER_IP }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${PRINTER_IP}/${{ secrets.PRINTER_IP }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${SNMP_COMMUNITY_ROUTER}/${{ secrets.SNMP_COMMUNITY_ROUTER }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${SNMP_COMMUNITY_PRINTER}/${{ secrets.SNMP_COMMUNITY_PRINTER }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${SNMP_PORT}/${{ secrets.SNMP_PORT }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${SNMP_VERSION}/${{ secrets.SNMP_VERSION }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${SNMP_TIMEOUT}/${{ secrets.SNMP_TIMEOUT }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                sed -i "s/\${SNMP_RETRIES}/${{ secrets.SNMP_RETRIES }}/g" "$DATADOG_DIR/conf.d/snmp.d/conf.yaml"
                echo "  ‚úÖ snmp.d/conf.yaml updated"
              fi
              
              echo "‚úÖ All environment variables substituted"
              
              # Clean up temp files
              rm -rf "/tmp/datadog-config"
            else
              echo "‚ö†Ô∏è  No configuration files found in temp location - creating them directly..."
              echo "üîß Creating configuration files directly via SSH..."
              
              # Create datadog.yaml directly
              cat > "$DATADOG_DIR/datadog.yaml" << 'DATADOG_EOF'
            # The host of the Datadog intake server to send Agent data to
            dd_url: https://app.datadoghq.com
            
            # The Datadog api key to associate your Agent's data with your organization.
            api_key: ${{ secrets.DD_API_KEY }}
            
            # Force the hostname to whatever you want. (default: auto-detected)
            hostname: Synology
            
            # Set the host's tags (optional)
            tags:
              - env:dev
              - deployment:synology
            
            # Set custom ports to match docker-compose configuration
            cmd_port: 5002
            expvar_port: 5003
            
            # Enable non-local traffic for DogStatsD
            dogstatsd_non_local_traffic: true
            
            # Enable metadata collection
            enable_metadata_collection: true
            
            # Enable inventories configuration
            inventories_configuration_enabled: true
            
            ####################################
            ## Trace Collection Configuration ##
            ####################################
            
            apm_config:
              enabled: true
              env: dev
              receiver_port: 8126
              apm_non_local_traffic: true
              compute_stats_by_span_kind: true
              # Point traces to HAProxy
              apm_dd_url: http://192.168.1.100:3835
            
            ####################################
            ## Remote Configuration ###########
            ####################################
            
            remote_configuration:
              enabled: true
              rc_dd_url: http://192.168.1.100:3846
              no_tls: true
            
            ####################################
            ## Forwarder Configuration ########
            ####################################
            
            # Forwarder timeout in seconds
            forwarder_timeout: 20
            
            # The forwarder retries failed requests. Use this setting to change the
            # maximum length of the forwarder's retry queue (each request in the queue
            # takes no more than 2MB in memory)
            forwarder_retry_queue_max_size: 30
            
            # Reduce check runners to prevent resource exhaustion
            check_runners: 2
            
            ####################################
            ## Logging Configuration ##########
            ####################################
            
            # Logging configuration - reduced verbosity to prevent log spam
            log_level: warn
            logs_enabled: true
            log_to_console: false
            
            # Main logs configuration
            logs_config:
              use_http: true
              logs_dd_url: http://192.168.1.100:8282
              use_compression: true
              compression_level: 6
              batch_wait: 5 # seconds between batches
              container_collect_all: true # This enables automatic log collection from all containers
            
            ####################################
            ## Process Configuration ##########
            ####################################
            
            process_config:
              process_collection:
                enabled: true
              container_collection:
                enabled: true
              # Disable network connections collection since system_probe network_config is disabled
              network:
                enabled: false
            
            ####################################
            ## Network Configuration ###########
            ####################################
            
            # Individual network path monitoring is configured via conf.d/network_path.d/conf.yaml
            
            ####################################
            ## System Probe Configuration ####
            ####################################
            
            # Disable advanced network monitoring features for kernel compatibility
            system_probe_config:
              # Disable system-probe to prevent connection errors
              enabled: false
            
            runtime_security_config:
              ## @param enabled - boolean - optional - default: false
              ## Disable Security Runtime Module to prevent connection errors
              #
              enabled: false
            
            compliance_config:
              ## @param enabled - boolean - optional - default: false
              ## Disable CIS benchmarks for CSPM to reduce resource usage
              #
              enabled: false
            
            # Disable network config to prevent loading network monitoring modules
            network_config:
              # Disable the main network monitoring that requires newer kernels
              enabled: false
              # Ignore conntrack failures for compatibility with older kernels
              ignore_conntrack_init_failure: true
            
            ## Note: Remove deprecated top-level `system_probe` block. System probe is
            ## controlled via `system_probe_config` and `network_config` above.
            
            network_devices:
              netflow:
                enabled: true
                listeners:
                  - flow_type: netflow9 # choices: netflow5, netflow9, ipfix, sflow5
                    port: 2055 # devices need to be configured to the same port number
                  - flow_type: netflow5
                    port: 2056
                  - flow_type: ipfix
                    port: 4739
                  - flow_type: sflow5
                    port: 6343
                ## Set to true to enable reverse DNS enrichment of private source and destination IP addresses in NetFlow records
                reverse_dns_enrichment_enabled: false
            
            ####################################
            ## Docker Configuration ###########
            ####################################
            
            listeners:
              - name: docker
            
            # Container discovery and autodiscovery settings
            container_collect_all: true
            
            # Enable container image collection
            container_image_enabled: true
            
            # Container lifecycle events
            container_lifecycle_events: true
            
            # Collect container labels as tags
            collect_ec2_tags: false
            collect_gce_tags: false
            docker_labels_as_tags:
              com.docker.compose.service: service
              com.docker.compose.project: project
              traefik.frontend.rule: traefik_rule
              traefik.backend: traefik_backend
            
            # Enable autodiscovery for containers - fix type casting issue
            ad_config_poll_interval: 10
            
            # Container monitoring optimizations for Synology
            container_exclude:
              - name:dd-agent # Exclude Datadog agent from monitoring itself
            
            container_include:
              - .* # Include all other containers
            
            # Keep the additional checksd configuration
            additional_checksd: /etc/datadog-agent/checks.d
            DATADOG_EOF
              
              echo "‚úÖ Created datadog.yaml directly"
              
              # Create PostgreSQL configuration
              cat > "$DATADOG_DIR/conf.d/postgres.d/conf.yaml" << 'POSTGRES_EOF'
            init_config:
            
            instances:
                # Enable Database Monitoring (required for query monitoring, explain plans, etc.)
              - dbm: true
                host: ${{ secrets.POSTGRES_HOST }} # can be an IP address, or hostname
                port: ${{ secrets.POSTGRES_PORT }}
                username: ${{ secrets.POSTGRES_USER }}
                password: ${{ secrets.POSTGRES_PASSWORD }}
                name: "Postgres-Dev" # This is the friendly name that will appear in Datadog
                reported_hostname: "Postgres-Dev" # Specifically for DBM visualization
                dbname: ${{ secrets.POSTGRES_DATABASE }}
                
                # Minimum collection, this will not require pg_stat_statements extension
                # but provides basic monitoring
                collect_function_metrics: false
                collect_count_metrics: true
                collect_activity_metrics: true
                collect_database_size_metrics: true
                collect_default_database: true
                
                # Enable statement metrics (required for query monitoring)
                collect_statement_metrics: true
                
                # Schema metrics (recommended for full DBM experience)
                schemas_collection:
                  enabled: true
                
                # Database metrics collection
                database_metrics:
                  # Enable metric collection for indexes
                  index_usage_metrics:
                    enabled: true
                
                # Collect table count to monitor table growth
                collect_table_count: true
                
                # Table metrics for detailed monitoring
                relations:
                  - relation_name: pg_stat_statements
                    schemas: [public]
                  - relation_regex: '.*'
                    relation_type: view, materialized_view, table, partitioned table
                    schemas: [public]
                
                # Tag metrics with the cluster name
                tags:
                  - "synology:postgres"
                  - "env:production"
                  
                # Connection options
                connect_timeout: 10
                
                # For hosts that are publicly accessible but firewalled
                use_tls: false 
            
                logs:
                - type: file
                  path: "/var/lib/postgresql/data/log/*.log"
                  source: postgresql
                  service: "Postgres"
                  log_processing_rules:
                    - type: multi_line
                      pattern: \d{4}\-(0?[1-9]|1[012])\-(0?[1-9]|[12][0-9]|3[01])
                      name: new_log_start_with_date
            POSTGRES_EOF
              
              echo "‚úÖ Created postgres.d/conf.yaml directly"
              
              # Create SQL Server configuration
              cat > "$DATADOG_DIR/conf.d/sqlserver.d/conf.yaml" << 'SQLSERVER_EOF'
            init_config:
            instances:
              - dbm: true
                # SQL Server connection (Linux agent): use ODBC connector
                host: ${{ secrets.SQLSERVER_HOST }}
                port: ${{ secrets.SQLSERVER_PORT }}
                username: ${{ secrets.SQLSERVER_USER }}
                # For dev/testing, set the cleartext password or configure the Agent secrets backend
                password: ${{ secrets.SQLSERVER_PASSWORD }}
                connector: odbc
                driver: 'FreeTDS'
                # TLS options for FreeTDS
                encrypt: false
                trust_server_certificate: true
                tds_version: 8.0
                # Timeout settings to prevent hanging connections
                query_timeout: 10
                connection_timeout: 5
                # Reduce collection frequency
                min_collection_interval: 60
                # Optional: tags
                tags:
                  - 'service:fastapi'
                  - 'env:dev'
            SQLSERVER_EOF
              
              echo "‚úÖ Created sqlserver.d/conf.yaml directly"
              
              # Create SNMP configuration
              cat > "$DATADOG_DIR/conf.d/snmp.d/conf.yaml" << 'SNMP_EOF'
            init_config:
              loader: core  # use core check implementation of SNMP integration. recommended
              use_device_id_as_hostname: true  # recommended
              ignore_nonincreasing_oid: true  # Ignore SNMP OID ordering issues
              
            instances:
              - ip_address: ${{ secrets.ROUTER_IP }}
                community_string: ${{ secrets.SNMP_COMMUNITY_ROUTER }}  # enclose with single quote
                # Use generic device profile to avoid autodetect failures
                profile: generic-device
                tags:
                    - "location:argyle"
                    - "facility:home"
            
              # This dash is also indented 2 spaces, same as the first instance
              - ip_address: ${{ secrets.PRINTER_IP }}
                # These keys are all aligned at 4 spaces
                port: ${{ secrets.SNMP_PORT }}
                community_string: ${{ secrets.SNMP_COMMUNITY_PRINTER }}
                snmp_version: ${{ secrets.SNMP_VERSION }}
                timeout: ${{ secrets.SNMP_TIMEOUT }}
                retries: ${{ secrets.SNMP_RETRIES }}
                min_collection_interval: 300
                device_id: brother-printer-nc8100w
                # Use generic device profile to avoid autodetect failures
                profile: generic-device
                tags:
                  - "printer:brother"
                  - "model:NC-8100w"
                  - "location:argyle"
                  - "facility:home"
            
              # Synology NAS - disable SNMP monitoring to prevent sysObjectID errors
              # The Synology NAS is running Linux net-snmp which doesn't have a predefined profile
              # Commented out to eliminate sysObjectID "1.3.6.1.4.1.8072.3.2.10" errors
              # - ip_address: '192.168.1.100'  # Your Synology NAS
              #   port: 161
              #   community_string: public
              #   snmp_version: 2
              #   timeout: 10
              #   retries: 5
              #   min_collection_interval: 300
              #   device_id: synology-nas
              #   tags:
              #     - "device_type:linux"
              #     - "snmp_device:synology-nas"
              #     - "location:argyle"
              #     - "facility:home"
            SNMP_EOF
              
              echo "‚úÖ Created snmp.d/conf.yaml directly"
              
              echo "üéØ All configuration files created successfully via SSH fallback method"
            fi
            
            # Set proper permissions on all config files
            find "$DATADOG_DIR" -name "*.yaml" -exec chmod 644 {} \;
            
            cd "$DATADOG_DIR"
            
            # List what we have
            echo "üìÇ Configuration files structure:"
            find "$DATADOG_DIR" -name "*.yaml" | head -20
            
            # Login to Docker Hub
            echo "üîê Logging into Docker Hub..."
            if ! echo "${{ secrets.DOCKERHUB_TOKEN }}" | $DOCKER_CMD login --username "${{ secrets.DOCKERHUB_USER }}" --password-stdin; then
              echo "‚ùå Failed to login to Docker Hub"
              exit 1
            fi
            
            # Pull the latest agent image
            echo "üì• Pulling latest Datadog Agent image..."
            $DOCKER_CMD pull ${{ secrets.DOCKERHUB_USER }}/dd-agent:latest
            
                  # OPW image pulling removed - deployed separately
            
            # Stop existing Datadog Agent container
            echo "üõë Stopping existing Datadog Agent..."
            $DOCKER_CMD stop dd-agent || echo "No existing dd-agent container to stop"
            $DOCKER_CMD rm dd-agent || echo "No existing dd-agent container to remove"
            
            # Clean up old containers and images
            echo "üßπ Cleaning up old resources..."
            $DOCKER_CMD container prune -f
            $DOCKER_CMD image prune -f
            
            # Deploy standalone Datadog Agent
            echo "üöÄ Starting standalone Datadog Agent..."
            $DOCKER_CMD run -d \
              --name dd-agent \
              --privileged \
              --restart unless-stopped \
              --network host \
              -e DD_API_KEY=${{ secrets.DD_API_KEY }} \
              -v /var/run/docker.sock:/var/run/docker.sock:ro \
              -v /proc:/host/proc:ro \
              -v /sys/fs/cgroup:/host/sys/fs/cgroup:ro \
              -v /sys/kernel/debug:/sys/kernel/debug \
              -v /etc/passwd:/etc/passwd:ro \
              -v /volume1/@docker/containers:/var/lib/docker/containers:ro \
              -v /volume1/docker/datadog-agent/datadog.yaml:/etc/datadog-agent/datadog.yaml:ro \
              -v /volume1/docker/datadog-agent/system-probe.yaml:/etc/datadog-agent/system-probe.yaml:ro \
              -v /volume1/docker/datadog-agent/conf.d:/etc/datadog-agent/conf.d:ro \
              --cap-add SYS_ADMIN \
              --cap-add SYS_RESOURCE \
              --cap-add SYS_PTRACE \
              --cap-add NET_ADMIN \
              --cap-add NET_BROADCAST \
              --cap-add NET_RAW \
              --cap-add IPC_LOCK \
              --cap-add CHOWN \
              --security-opt apparmor:unconfined \
              --label "deployment.timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" \
              --label "deployment.source=github-actions" \
              --label "deployment.commit=${{ github.sha }}" \
              --label "deployment.repository=${{ github.repository }}" \
              ${{ secrets.DOCKERHUB_USER }}/dd-agent:latest
            
            # Wait for service to be ready
            echo "‚è≥ Waiting for Datadog Agent to start..."
            sleep 30
            
            # Verify service is running
            echo "üîç Verifying Datadog Agent status..."
            if $DOCKER_CMD ps | grep -q "dd-agent.*Up"; then
              echo "‚úÖ Datadog Agent is running"
            else
              echo "‚ùå Datadog Agent failed to start"
              $DOCKER_CMD logs dd-agent
              exit 1
            fi
            
            # Health check
            echo "üè• Performing health checks..."
            
            # Check Datadog Agent health
            if $DOCKER_CMD exec dd-agent /opt/datadog-agent/bin/agent/agent health 2>/dev/null; then
              echo "‚úÖ Datadog Agent health check passed"
            else
              echo "‚ö†Ô∏è  Datadog Agent health check failed - checking logs..."
              $DOCKER_CMD logs dd-agent --tail 20
            fi
            
            # Show final status
            echo "üìä Final service status:"
            $DOCKER_CMD ps --filter "name=dd-agent"
            
            echo "üéâ Datadog Agent deployment completed successfully!"
            echo "üìç Agent Status: http://localhost:5002/status"
            echo "üìç Agent sends logs to OPW at: http://dd-opw:8282 (deployed separately)"
      
      # Mark deployment in Datadog (only for main branch)
      - name: Mark Deployment in Datadog
        if: steps.synology_deploy.outcome == 'success' && github.ref == 'refs/heads/main'
        env:
          DD_API_KEY: ${{ secrets.DD_API_KEY }}
          DD_SITE: datadoghq.com
          DD_BETA_COMMANDS_ENABLED: 1
        run: |
          REVISION="${{ github.sha }}"
          SHORT_SHA="${REVISION:0:7}"
          DEPLOY_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          
          echo "üìä Marking Datadog Agent deployment..."
          echo "Environment: infrastructure"
          echo "Service: datadog-agent"
          echo "Revision: $SHORT_SHA"
          echo "Deploy Time: $DEPLOY_TIME"
          
          # Mark the deployment
          datadog-ci deployment mark \
            --env "infrastructure" \
            --service "datadog-agent" \
            --revision "$SHORT_SHA" \
            --tags "deployment_method:github_actions" \
            --tags "repository:${{ github.repository }}" \
            --tags "branch:${{ github.ref_name }}" \
            --tags "actor:${{ github.actor }}" \
            --tags "workflow:${{ github.workflow }}" \
            --tags "run_id:${{ github.run_id }}" \
            --tags "deploy_time:$DEPLOY_TIME" \
            --tags "component:monitoring" \
            --tags "infrastructure:synology" \
            --no-fail || echo "‚ö†Ô∏è  Failed to mark deployment in Datadog (non-blocking)"
          
          echo "‚úÖ Deployment marked in Datadog successfully!"
      
      # Notification on failure
      - name: Notify on Failure
        if: failure()
        run: |
          echo "‚ùå Datadog Agent deployment failed!"
          echo "Please check the logs and configuration files."
          echo "Common issues:"
          echo "- Docker Hub authentication"
          echo "- SSH connection to Synology"
          echo "- Invalid YAML configuration"
          echo "- Missing secrets" 